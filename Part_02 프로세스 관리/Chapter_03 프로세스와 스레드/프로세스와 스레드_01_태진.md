## 01_프로세스의 개요

### 프로세스의 개념

- 폰노이만 구조에서 프로그램이 실행된다는 것은 해당 코드가 메모리에 올라와서 작업이 진행됨을 의미.
- 프로그램은 저장장치에 저장된 정적인 상태 / 프로세스는 실행을 위에 메모리에 올라온 동적인 상태
- 누군가가 작성한 '프로그램'이 실행되면 '**프로세스**'가 됨.

### 요리사 모형의 비유

#### 주문서의 역할

- 주문서는 메뉴판(프로그램)이 실행된 상태이므로 프로세스에 해당된다.

#### 일괄 작업 방식의 요리

- 주방에서는 주문서가 도착한 순서대로 요리를 하기 위해 '주문 목록'을 사용함.
- 이 형태는 큐(queue)

#### 시분할 작업 방식의 요리

- 요리사가 1명이지만 시간을 적당히 배분하여 여러 가지 요리를 동시에 하는 시분할 방식
  - 손님이 식사하는 시간을 충분히 활용하면 요리사 여러 명이 요리하는 효과를 냄. 
  

- CPU가 1개인 컴퓨터에서 여러 개의 프로세스를 동시에 실행하는 원리.
  - CPU가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 프로세스가 동시에 실행되는 것처럼 느껴짐.


### 프로그램에서 프로세스로의 전환

- 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다. 
  - 주문과 동시에 주문서에 해당되는 작업 지시서를 만든다.
  - 이를 프로세스 제어 블록(PCB : Process Control Block)
- 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록은 받았다는 의미.

> - 프로세스 구분자 : 프로세스 ID를 뜻함. PID임. 
> - 메모리 정보 : CPU는 프로세스가 메모리의 어디에 저장되어 있는지 알아야함.
> - 각종 중간값 : 프로세스가 사용했던 중간값이 저장됨. 
>   - 어떤 단품 요리까지 손님에게 제공되었는지 주문서에 표시하는것과 유사함. 
>   - 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘김.
>   - 다음에 작업해야할 코드의 위치가 담긴 레지스터인 '프로그램 카운터'가 저장됨.

#### 프로세스와 프로그램의 관계

- 프로세스 = 프로그램 + 프로세스 제어 블록
- 프로그램 = 프로세스 - 프로세스 제어 블록

- 부트 스트랩이 운영체제 관련 프로세스를 실행한 후 일반 프로세스가 실행됨. 
- user process와 kernel process가 실행된다.


### 프로세스의 상태

일괄 작업 시스템보다 실행 관련 상태가 복잡하다.

#### 프로세스의 네가지 상태

- 생성 상태(create status) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. PCB가 생성됨.
  - PCB는 커널 영역에 만들어짐. 이후에 준비 상태로 이동함.
- 준비 상태(ready status) : 생성된 프로세스가 CPU를 얻을때까지 기다림. 레스토랑의 예에서는 주문 목록이 준비 상태.
  - PCB는 준비 큐(ready queue)에서 기다리며 스케쥴러에 의해 관리됨. 
  - 실제로는 다수의 준비 큐가 운영된다.
- 실행 상태(running status) : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 수행 상태. execute status라고도 함.
  - 실행 상태에 들어가는 프로세스의 수는 CPU의 개수 만큼이다.
- 완료 상태(terminate status) : 완료 상태는 프로세스 제어 블록이 사라진 상태. 작업 완료 상태임.
  - 만약 오류나 다른 프로세스에 의해 비정상적으로 종료되는 강제종료(abort)를 만나면 디버깅 하기위해 강제 종료 직전의 메모리 상태를 저장장치로 옮긴다.
  - 이를 코어 덤프(core dump)라고 함. 종료 직전의 메모리 상태를 확인함으로써 오류를 수정할 수 있게 해줌.

진행 과정
- CPU 스케쥴러 : 준비 상태의 프로세스가 실행상태로 넘어가는 것은 **'디스패치'** 그러한 행위는 스케쥴러가 한다. 
- 타임 퀀텀(타임 슬라이스) : 프로세스 실행 상태에서 프로세스에 배당된 작업 시간.
- 실행 중 할당 시간을 벗어나면 클록에게 알려달라고 요청한다.(알람과 비슷함.)
- 클록은 **'타임아웃(인터럽트)'** 사용하여 일정 시간이 흘렀다고 CPU에게 알려줌.

#### 프로세스의 다섯 가지 상태

- 대기상태(blocking status)가 추가됨.
- 대기상태는 프로세스 실행 상태 중 입출력을 요구 받았을 때 입출력 관리자에게 명령을 내려 데이터를 가져오게함.
  - 이때가 레스토랑의 예에서 새우가 손질되지 않아 기다리는 상황임. 
- 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태를 대기 상태라 한다. 
- 스케쥴러는 입출력 요청한 프로세스가 대기 상태로 옮겨지면 준비 상태에 있는 프로세스를 실행 상태로 만든다. 
- 대기 상태에서 입출력이 끝난 프로세스는 실행 상태로 가지 않고 준비 상태로 돌아가 차례를 기다린다.
- 어떤 프로세스가 대기 상태에서 준비상태로 이동하는것은 인터럽트 때문이다.

##### 휴식 상태와 보류 상태

- 다섯가지 상태를 활성 상태(active status)라고 한다.
- 이 외에 휴식 상태와 보류 상태가 있음.

휴식 상태(pause status)
- 프로세스가 작업을 일시적으로 쉬고 있는 상태.
- 유닉스에서 ctrl + z 를 누르면 확인 가능. jobs나 ps 명령어로 보면 상태가 '정지(stop)' 임을 알 수 있음.
- 사용하던 데이터가 메모리에 그대로 있고 PCB도 유지되고 재시작 가능한 상태.

보류 상태(suspend status)
- 프로세스가 메모리에서 잠시 쫓겨난 상태.
- 메모리가 꽉차서 일부 프로세스를 메모리 밖으로 내보내기 or 오류가 있어서 실행을 미루기 or 바이러스 or 매우 긴 주기로 반복되는 프로세스 or 입출력 대기 시 지연되고 있을 때.
- 보류 상태에 들어간 프로세스는 스왑 영역(swap area)에 보관된다. 

## 02_프로세스 제어 블록과 문맥 교환

### 프로세스 제어 블록(PCB)

각종 큐에는 PCB가 아닌 포인터만 들어간다. 
포인터는 물리적 주소이 정보를 가지고 있고 이 값을 이용해 PCB 정보를 찾아올수 있다.


구성
- 포인터 : 첫번째 블록에 포인터가 저장되며. 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용함.
- 프로세스 상태 : 두번째 블록에 저장됨.
- 프로세스 구분자 : PID
- 프로세스 카운터 : 다음에 실행된 명령어의 위치를 가리키는 프로그램 카운터를 저장함.
- 우선순위 : 커널 프로세스 > 대기 상태의 큐도 우선순위 별로 운영.
- 각종 레지스터 정보 : 누산기(accumulator), 색인 레지스터(index register), 스택 포인터(stack pointer)와 같은 값이 저장됨.
- 메모리 관리 정보 : 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터 값, 한계 레지스터 값이 저장됨.
  - 세그먼테이션 테이블(segmentation table), 페이지 테이블(page table)등 도 저장함.
- 할당된 자원 정보 : 입출력 자원, 오픈파일. 하드디스크에 저장된 파일을 열거나, 음악을 출력하기 위한 물리적 정보.
- 계정 정보 : 계정 번호, cpu 할당 시간, cpu 사용시간 등
- 부모 프로세스 구분자와 자식 프로세스 구분자 : PPID(parent pid), CPID(child pid)정보도 포함됨.


### 문맥 교환(context switching)

- CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말한다.
- 두 프로세스의 PCB를 교환하는 작업이 문맥 교환이다.

#### 문맥 교환의 절차
- 타임아웃 발생 시 현재까지의 작업결과를 PCB에 저장하고, 불러오는 방식으로 진행됨.
- 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생
- 인터럽트가 걸렸을 때도 발생
  - 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 할때 경계 레지스터의 범위를 벗어남
    - 이 때 인터럽트가 발생하여 현재 실행 중인 프로세스의 제어 블록을 저장한 후 인터럽트 관리 프로세스를 실행 상태로 만듬.
    - 인터럽트를 처리할 때도 문맥 교환이 일어남.


#### 문맥 교환과 타임 슬라이스의 크기
- 타임 슬라이스가 너무 작을 경우 문맥 교환이 잦기 때문에 시스템 성능이 떨어짐.
- 문맥 교환에도 시간이 걸리기 때문에 작업 시간보다 크다면 비효율적이게 낭비해버리게 됨.
- 결론은, 문맥 시간을 고려하여 적당하게 해야한다.
- unix에서는 대략 100밀리초이며, 10~200밀리초 사이에서 조정한다.

