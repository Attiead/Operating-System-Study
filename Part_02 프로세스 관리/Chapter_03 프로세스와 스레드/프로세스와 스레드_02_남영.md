## 03_프로세스의 연산

### 프로세스의 구조
- 코드 영역
    - 프로그램의 본문이 기술된 영역 (텍스트 영역)
    - 읽기 전용으로 처리 됨 (자기 자신을 수정하는 프로그램은 존재하지 않는다.)
- 데이터 영역
    - 코드가 실행되며 사용하는 변수나 파일 등의 각종 데이터를 모아 놓는 영역
    - 데이터는 변하는 값이므로 읽기와 쓰기가 가능하다.
- 스택 영역
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아 놓은 곳
    - 프로세스 내에서 함수를 호출하면, 원래 프로그램으로 되돌아올 위치를 이 영역에 저장
    - 사용자에게는 보이지 않음

---

### 프로세스의 생성과 복사
- fork() 시스템 호출의 개념
    - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
    - 커널에서 제공, 일종의 시스템 호출
    - 새로운 워드 프로세스를 실행하면 이 시스템 호출이 실행된다. (새로 만드는 것보다 속도가 훨씬 빠르다.)
    - 부모 - 자식 관계로 연결된다.
- fork() 시스템 호출의 동작 과정
    - 프로세스 제어 블럭을 포함한 부모 프로ㅔ스 영역의 대부분이 자식 프로세스에 복사 되어 동일한 프로세스가 생성 된다.
        - 프로세스 구분자가 바뀐다.
        - 메모리 관련 정보가 바뀌낟.
        - ppid, cpid 가 바뀐다. 자식 프로세스의 cpid 는 -1
- fork() 시스템 호출의 장점
    - 프로세스의 생성 속도가 빠르다.
    - 추가 작업 없이 자원을 상속 가능하다.
    - 시스템 관리를 효율적으로 할 수 있다.

---

### 프로세스의 전환
- exec() 시스템 호출의 개념
    - 기존의 프로세스를 새로운 프로세스로 전환하는 함수
    - 프로세스의 구조체를 재활용하기 위한 목적
    - 이미 생성 된 PCB, Memory, 부모-자식 관계를 그대로 사용 가능하다.
    - OS의 작업이 한결 수월해짐.
- exec() 시스템 호출의 동작 과정
    - 코드 영역에 있는 기존 내용을 지우고, 새로운 코드로 변경, 스택 영역이 리셋
    - pid, ppid, pcid 불변, Program counter registry 값 등 각종 레지스터와 사용한 파일 정보가 리셋 됨.

---

## 04. 프로세스의 계층 구조

### 유닉스의 프로세스 계층 구조
- 유닉스에서 커널이 처음 메모리에 올라와 부팅이 되면, 커널 관련 프로세스를 여러 개 생성한다.
- init 프로세스는 전체 프로세스의 출발점이 된다
- 하위 프로세스의 경우, 모두 자식이 되는 트리 구조를 이룬다.

---
### 프로세스 계층 구조의 장점
- 프로세스의 계층 구조는 동시에 여러 작업을 처리하고 종료된 프로세스의 자원을 회수하는 데 유용하다.
 - 프로세스를 계층 구조로 만들면, 관계 간 책임이 분명해져, 시스템을 관리하기 수월하다.
 - 작업을 마친 프로세스의 자원을 회수할 때 특히 편리하다.
 
---
### 미아 프로세스
- 부모 프로세스가 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료되어 부모 프로세스에 연락이 안 되는 경우, 사용하던 자원이 그대로 남게 된다.
- "좀비프로세스"
- OS 는 반환 되지 못한 자원을 회수하는 자원 회수를 주기적으로 해야 한다.
- C 언어의 return, exit 함수는 자식 프로세스의 작업이 끝난다는 것을 부모에게 알리는 것이다.
- 이를 통해 부모는 동기화가 가능하다.
- 이는 현대 객체 지향 언어에도 동일하게 적용한다. ex) Java 의 Object 클래스

## 4. 스레드

### 스레드의 개념
- 프로세스의 코드에 정의된 절차에 따라 CPU 에 작업 요청을 하는 실행 단위

---

### 프로세스의 스레드의 차이
- 스레드
    - 스레드는 프로세스 내부에서 서로 강하게 연결 되어 있다.
- 멀티태스크
    - 서로 독립적인 프로세스는 데이터를 주고받을 때 프로세스 간 통신 IPC 통신을 이용한다.
- 멀티스레드
    - 멀티스레드는 변수나 파일 등을 공유하며 전역 변수나 함수 호출 등의 방법으로 스레드 간 통신을 한다.
- 멀티프로세싱
    - CPU 를 여러 개 사용하여 여러 개의 스레드를 동시에 처리하는 작업 환경
    - 병렬 처리에서의 슈퍼스칼라 기법과 같다.
    - 여러 개의 CPU 혹은 하나의 CPU 내 여러 개의 코어에 스레드를 배정하여 동시에 작동
    - 동일한 네트워크에 여러 컴퓨터에 스레드를 나누어 협업하는 분산 시스템도 멀티프로세싱이다.
- CPU 멀티스레드
    - 한 번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

---

### 멀티스레드의 구조와 예
- 멀티태스킹의 낭비 요소를 제거하기 위해 사용한다.
- 응답성 향상에 도움이 된다.
- 자원 공유가 원활하다.
- 효율성 향상에 도움이 된다.
- 하지만, 한 스레드에 문제가 생길 경우, 전체 프로세스에 영향을 미친다.
--- 

### 멀티스레드 모델
- 커널 스레드
    - 커널이 직접 생성하고 관리하는 스레드
    - 커널이 멀티스레드를 지원하는 방식하나의 사용자 스레드가 하나의 커널 스레드와 연결되기 때문에, 1 to 1 모델이라 부른다.
    - 독립적으로 스케쥴링 되므로 특정 스레드가 대기 상태에 들어가도 작업을 계속할 수 있다.
    - 또한 커널이 제공하는 보호 기능과 같은 모든 기능을 사용 가능함.

- 사용자 스레드
    - 라이브러리에 의해 구현된 일반적인 스레드
    - 커널 입장에서 이 스레드는 하나의 프로세스처럼 보인다.
    - 커널 스레드와 1:N 관계
    - 라이브러리가 직접 스케쥴링을 하고 작업에 필요한 정보를 처리하기 때문에 문맥 교환이 필요 없다.
    - 여러 개의 스레드가 하나의 커널 스레드와 연결 되므로, 커널 스레드가 IO 작업을 위해 대기 상태일 때 연결 된 모든 사용자 스레드도 대기한다.
    - 한 프로세스의 타임 슬라이스르 여러 스레드가 공유하므로, 여러 개의 CPU 를 동시에 사용할 수 없다. 하지만 커널의 경우 스레드를 여러 CPU 에 나누어 작업시키는 것이 가능하다.
    - 또한 사용자 레벨 스레드는 보안에 취약하다. 커널 레벨에서는 공유 변수를 보호하는 장치가 있다.

- 멀티레벨 스레드
    - 사용자 레벨, 커널 스레드를 혼합한 방식
    - 문맥 교환의 오버헤드가 있어 빠르진 않다.

---
